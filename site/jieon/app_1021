# -*- coding: utf-8 -*-
"""
Streamlit app (ìˆ˜ì •ë³¸)
- Streamlit ë²„ì „ ì°¨ì´(st.rerun / st.experimental_rerun) ì•ˆì „ ì²˜ë¦¬ ì¶”ê°€
- image_visualizer_colab_ver ë™ì‘ì„ ë¡œì»¬/pycharm í™˜ê²½ì—ì„œ ë™ì‘í•˜ë„ë¡ ì •ë¦¬
- ê¸°ì¡´ ê¸°ëŠ¥ ìœ ì§€(ë©”íƒ€ë°ì´í„° ê¸°ë°˜ í˜ì´ì§€ ë¡œë“œ, ë¶„ì„ íŒŒì´í”„ë¼ì¸, GPT ì—°ë™)
"""
import os
import time
import logging
import json
import importlib
from typing import Optional
import streamlit as st
from dotenv import load_dotenv

# app.py ìµœìƒë‹¨ì— ì¶”ê°€ (ê¸°ì¡´ importë“¤ ë°”ë¡œ ì•„ë˜)
import os, sys

# í”„ë¡œì íŠ¸ êµ¬ì¡°ìƒ app.pyê°€ ìˆëŠ” ë””ë ‰í† ë¦¬ê°€ íŒ¨í‚¤ì§€ ë£¨íŠ¸ì´ë¯€ë¡œ ì•„ë˜ ê²½ë¡œ ì¶”ê°€ëŠ” ëŒ€ê°œ ë¶ˆí•„ìš”.
# ê·¸ë˜ë„ ì•ˆì „í•˜ê²Œ í˜„ì¬ íŒŒì¼(=app.py)ì´ ìˆëŠ” ë””ë ‰í† ë¦¬ë¥¼ sys.pathì— ë„£ìŠµë‹ˆë‹¤.
APP_ROOT = os.path.abspath(os.path.dirname(__file__))
if APP_ROOT not in sys.path:
    sys.path.insert(0, APP_ROOT)

# ergonomics/ergonomics_analyzer.pyì—ì„œ í´ë˜ìŠ¤ë¥¼ ì§ì ‘ import
try:
    from ergonomics.ergonomics_analyzer import ErgonomicsAnalyzer
except Exception as e:
    # ì„í¬íŠ¸ ì‹¤íŒ¨ ì‹œ ê°œë°œìš© ë©”ì‹œì§€ ë…¸ì¶œ (ì½˜ì†”/Streamlitì—ì„œ í™•ì¸ ê°€ëŠ¥)
    import logging
    logging.exception("ergonomics ëª¨ë“ˆ ì„í¬íŠ¸ ì‹¤íŒ¨: %s", e)
    ErgonomicsAnalyzer = None

# NOTE: OpenAI ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì„ íƒì ì…ë‹ˆë‹¤. í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²½ìš° None ì²˜ë¦¬ë©ë‹ˆë‹¤.
try:
    from openai import OpenAI
except Exception:
    OpenAI = None

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Streamlit secrets -> os.environ (ê°€ëŠ¥í•˜ë©´)
try:
    if "OPENAI_API_KEY" not in os.environ and st.secrets.get("OPENAI_API_KEY"):
        os.environ["OPENAI_API_KEY"] = st.secrets["OPENAI_API_KEY"]
except Exception:
    pass

# ------------------------
# ì•ˆì „í•œ rerun í—¬í¼ (Streamlit ë²„ì „ ì°¨ì´ ì²˜ë¦¬)
# ------------------------
def _safe_rerun():
    """Streamlit ë²„ì „ ì°¨ì´ë¥¼ í¡ìˆ˜í•˜ëŠ” ì•ˆì „í•œ rerun í˜¸ì¶œ."""
    if hasattr(st, "rerun") and callable(getattr(st, "rerun")):
        st.rerun()
    elif hasattr(st, "experimental_rerun") and callable(getattr(st, "experimental_rerun")):
        st.experimental_rerun()
    else:
        raise RuntimeError("Streamlit rerun ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. st.rerun ë˜ëŠ” st.experimental_rerunì´ í•„ìš”í•©ë‹ˆë‹¤.")

# ------------------------
# OpenAI ìœ í‹¸ë¦¬í‹°
# ------------------------
def make_openai_client() -> Optional[OpenAI]:
    key = os.environ.get("OPENAI_API_KEY")
    if not key or OpenAI is None:
        logger.info("OpenAI API í‚¤ê°€ ì—†ê±°ë‚˜ openai ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return None
    try:
        return OpenAI(api_key=key)
    except Exception:
        logger.exception("OpenAI í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨")
        return None

def extract_text_from_response(resp) -> str:
    try:
        if hasattr(resp, "choices") and len(resp.choices) > 0:
            ch = resp.choices[0]
            if hasattr(ch, "message") and hasattr(ch.message, "content"):
                return ch.message.content.strip()
            if hasattr(ch, "text"):
                return ch.text.strip()
        if isinstance(resp, dict):
            choices = resp.get("choices")
            if choices and isinstance(choices, list):
                first = choices[0]
                if isinstance(first, dict):
                    return first.get("message", {}).get("content", "") or first.get("text", "")
    except Exception:
        logger.exception("ì‘ë‹µ íŒŒì‹± ì¤‘ ì˜¤ë¥˜")
    return "ì‘ë‹µì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

# ì „ì—­ client (ì§€ì—° ìƒì„±)
client: Optional[OpenAI] = None

# ------------------------
# GPT ì—°ë™ í•¨ìˆ˜
# ------------------------
def get_gpt_recommendation(report: list) -> str:
    global client
    if client is None:
        client = make_openai_client()
    if not client:
        return "âš ï¸ OpenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. OPENAI_API_KEYë¥¼ í™•ì¸í•˜ì„¸ìš”."
    report_str = json.dumps(report, indent=2, ensure_ascii=False)
    prompt_text = (
        "ë‹¤ìŒì€ ì‚¬ìš©ìì˜ ì±…ìƒ í™˜ê²½ì— ëŒ€í•œ ì¸ì²´ê³µí•™ ë¶„ì„ ê²°ê³¼(JSON í˜•ì‹)ì…ë‹ˆë‹¤:\n"
        f"```json\n{report_str}\n```\n\n"
        "ë‹¹ì‹ ì€ ì„¸ê³„ ìµœê³ ì˜ ì¸ì²´ê³µí•™ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ìœ„ ë¶„ì„ ê²°ê³¼ë¥¼ í•´ì„í•˜ì—¬, ì‚¬ìš©ìì—ê²Œ ë§¤ìš° êµ¬ì²´ì ì´ê³  ì‹¤ìš©ì ì¸ ì±…ìƒ í™˜ê²½ ê°œì„  ë°©ì•ˆì„ í•œêµ­ì–´ë¡œ ì¹œì ˆí•˜ê²Œ ì„¤ëª…í•´ì£¼ì„¸ìš”.\n"
        "ë²ˆí˜¸ ëª©ë¡ í˜•ì‹ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒ ë‚´ìš©ì„ ë°˜ë“œì‹œ í¬í•¨í•˜ì—¬ ì¡°ì–¸í•´ì£¼ì„¸ìš”:\n"
        "1. **ì¢…í•© ì§„ë‹¨**: í˜„ì¬ ìƒí™©ì— ëŒ€í•œ ê¸ì •ì ì¸ ì ê³¼ ê°€ì¥ ì‹œê¸‰í•˜ê²Œ ê°œì„ í•´ì•¼ í•  ì ì„ ìš”ì•½í•´ì£¼ì„¸ìš”.\n"
        "2. **ìƒì„¸ ê°œì„  ë°©ì•ˆ**: ë¶„ì„ ê²°ê³¼ì—ì„œ 'severity'ê°€ 'High' ë˜ëŠ” 'Moderate'ì¸ ë¬¸ì œì ë“¤ì„ ì¤‘ì‹¬ìœ¼ë¡œ, ê°ê°ì— ëŒ€í•œ êµ¬ì²´ì ì¸ í•´ê²°ì±…ì„ ì œì‹œí•´ì£¼ì„¸ìš”.\n"
        "3. **ì¶”ê°€ì ì¸ íŒ**: ë¶„ì„ ë¦¬í¬íŠ¸ì— ë‚˜íƒ€ë‚˜ì§€ ì•Šì•˜ë”ë¼ë„, ê±´ê°•í•œ ì»´í“¨í„° ì‘ì—…ì„ ìœ„í•œ ì¼ë°˜ì ì¸ ì¸ì²´ê³µí•™ íŒ(ìŠ¤íŠ¸ë ˆì¹­, íœ´ì‹ ì‹œê°„)ì„ 2-3ê°€ì§€ ì œì•ˆí•´ì£¼ì„¸ìš”.\n"
    )
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a world-class ergonomics expert providing advice in Korean."},
                {"role": "user", "content": prompt_text}
            ],
            temperature=0.7,
            max_tokens=1024,
            timeout=45
        )
        return extract_text_from_response(response)
    except Exception as e:
        logger.exception("GPT í˜¸ì¶œ ì‹¤íŒ¨")
        return f"GPT API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {type(e).__name__}: {e}"

# ------------------------
# Helper: sessionì—ì„œ ì‚¬ìš©ì ì…ë ¥ ë³µì›
# ------------------------
def normalize_user_inputs() -> dict:
    ui = {}
    sess = st.session_state
    candidate = sess.get("user_inputs") or sess.get("user_info") or {}
    if "user_height_cm" in candidate:
        ui["user_height_cm"] = candidate["user_height_cm"]
    elif "height" in candidate:
        ui["user_height_cm"] = candidate["height"]
    elif "í‚¤" in candidate:
        ui["user_height_cm"] = candidate["í‚¤"]
    gender = candidate.get("gender") or candidate.get("ì„±ë³„")
    if isinstance(gender, str):
        g = gender.lower()
        if "ë‚¨" in g or "male" in g:
            ui["gender"] = "male"
        elif "ì—¬" in g or "female" in g:
            ui["gender"] = "female"
        else:
            ui["gender"] = gender
    handed = candidate.get("handedness") or candidate.get("dominant_hand") or candidate.get("ì£¼ ì‚¬ìš© ì†")
    if isinstance(handed, str):
        h = handed.lower()
        if "ì™¼" in h or "left" in h:
            ui["handedness"] = "left"
        else:
            ui["handedness"] = "right"
    return ui

# ------------------------
# Streamlit ì•± ë©”ì¸ ë° ë„¤ë¹„ê²Œì´ì…˜
# ------------------------
st.set_page_config(page_title="ì¸ì²´ê³µí•™ì  ì±…ìƒ ê°œì„  ê°€ì´ë“œ", page_icon="ğŸ¦¾", layout="centered")
st.title("ğŸ¦¾ ì¸ì²´ê³µí•™ì  ì±…ìƒ ê°œì„  ê°€ì´ë“œ ì„œë¹„ìŠ¤")
st.markdown("---")

if 'current_page' not in st.session_state:
    st.session_state['current_page'] = 1

def go_to_page(page_num: int):
    st.session_state['current_page'] = page_num
    _safe_rerun()

def handle_retry():
    keys_to_reset = [
        'current_page', 'user_analysis', 'analysis_result', 'detailed_report',
        'yolo_output', 'user_inputs', 'selected_screen_id', 'selected_screen_inch', 'image_width_px',
        'workflow_result', 'main_screen', 'monitor_inch', 'main_screen'
    ]
    for key in keys_to_reset:
        if key in st.session_state:
            del st.session_state[key]
    st.session_state['current_page'] = 1
    _safe_rerun()

def display_page():
    page_id = st.session_state.get('current_page', 1)
    pages_dir = "pages"
    meta_path = os.path.join(pages_dir, "metadata.json")
    if not os.path.exists(pages_dir) or not os.path.exists(meta_path):
        st.warning("pages ë””ë ‰í† ë¦¬ ë˜ëŠ” pages/metadata.json íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return
    try:
        with open(meta_path, "r", encoding="utf-8") as f:
            metadata = json.load(f)
        page_info = next((p for p in metadata.get("pages", []) if p.get("id") == page_id), None)
        if page_info:
            module = importlib.import_module(f"pages.{page_info['module']}")
            func = getattr(module, page_info['function'])
            func()
    except Exception as e:
        logger.exception("í˜ì´ì§€ ë¡œë”© ì‹¤íŒ¨")
        st.error(f"í˜ì´ì§€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

display_page()
st.markdown("---")

page = st.session_state.get('current_page', 1)

if page == 1:
    if st.button("Start Analysis", key="start_p1", use_container_width=True):
        go_to_page(2)
elif page == 2:
    cols = st.columns(3)
    with cols[0]:
        if st.button("< Back", key="back_p2", use_container_width=True):
            go_to_page(1)
    with cols[2]:
        if st.button("Next >", key="next_p3", use_container_width=True):
            go_to_page(3)
elif page == 3:
    cols = st.columns(3)
    with cols[0]:
        if st.button("< Back", key="back_p3", use_container_width=True):
            go_to_page(2)
    with cols[2]:
        if st.button("Get My Ergonomic Report", key="next_p4", use_container_width=True):
            go_to_page(4)
elif page == 4:
    st.header("â±ï¸ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...")
    st.info("AIê°€ ë‹¹ì‹ ì˜ ì±…ìƒ í™˜ê²½ì„ ì •ë°€ ë¶„ì„í•˜ê³  ë§ì¶¤í˜• ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤.")
    try:
        workflow_result = st.session_state.get('workflow_result', [{}])
        workflow_item = workflow_result[0] if isinstance(workflow_result, list) and len(workflow_result) > 0 else workflow_result
        main_screen_raw = st.session_state.get('main_screen')
        main_screen_inch = st.session_state.get('monitor_inch')
        user_inputs = normalize_user_inputs()
        if not workflow_item or not main_screen_raw or not main_screen_inch:
            st.error("ë¶„ì„ì— í•„ìš”í•œ ì´ë¯¸ì§€ ë˜ëŠ” ë©”ì¸ ìŠ¤í¬ë¦° ì •ë³´ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. 2ë‹¨ê³„ë¡œ ëŒì•„ê°€ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
            if st.button("ëŒì•„ê°€ê¸°"):
                handle_retry()
            st.stop()
        raw_detections = workflow_item.get("predictions", {}).get("predictions", [])
        image_width = workflow_item.get("image", {}).get("width", 1280)
        yolo_results = []
        for det in raw_detections:
            yolo_results.append({
                "class": det.get("class"),
                "confidence": det.get("confidence"),
                "box": {"x": det.get("x"), "y": det.get("y"), "width": det.get("width"), "height": det.get("height")}
            })
        main_screen_id = None
        for i, det in enumerate(yolo_results):
            if (det['box']['x'] == main_screen_raw.get('x') and
                    det['box']['y'] == main_screen_raw.get('y') and
                    det['class'] == main_screen_raw.get('class')):
                det['id'] = f"screen_{i}"
                main_screen_id = f"screen_{i}"
                break
        if not main_screen_id:
            for i, det in enumerate(yolo_results):
                if det.get("class") in ["screen", "monitor", "laptop"]:
                    det['id'] = f"screen_{i}"
                    main_screen_id = f"screen_{i}"
                    break
        if ErgonomicsAnalyzer is None:
            st.error(
                "ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ErgonomicsAnalyzer í´ë˜ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ergonomics/ergonomics_analyzer.py ê²½ë¡œì™€ __init__.pyë¥¼ í™•ì¸í•˜ì„¸ìš”.")
            st.stop()
        # ê·¸ ë‹¤ìŒ ë°”ë¡œ ì‚¬ìš©
        analyzer = ErgonomicsAnalyzer(yolo_results, user_inputs or {}, image_width)
        analyzer = ErgonomicsAnalyzer(yolo_results, user_inputs or {}, image_width)
        analyzer.set_main_screen_by_id(main_screen_id, str(main_screen_inch))
        analysis_report = analyzer.run_all_analyses()
        st.session_state['detailed_report'] = analysis_report
        gpt_text = get_gpt_recommendation(analysis_report)
        st.session_state['analysis_result'] = gpt_text
        st.success("ë¶„ì„ ë° ë¦¬í¬íŠ¸ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
        time.sleep(0.6)
        go_to_page(5)
    except Exception as e:
        logger.exception("ë¶„ì„ íŒŒì´í”„ë¼ì¸ ì˜¤ë¥˜")
        st.error(f"ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        if st.button("ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ê¸°", on_click=handle_retry):
            pass
        st.stop()
elif page == 5:
    st.subheader("ğŸ“Š ë‹¹ì‹ ì„ ìœ„í•œ AI ì¸ì²´ê³µí•™ ë¶„ì„ ë¦¬í¬íŠ¸")
    final_result = st.session_state.get('analysis_result', "ë¶„ì„ ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    st.markdown(final_result)
    st.markdown("---")
    try:
        import base64
        from importlib import import_module
        image_visualizer = import_module("image_visualizer")
    except Exception:
        image_visualizer = None
        logger.exception("image_visualizer ëª¨ë“ˆ ë¡œë“œ ì‹¤íŒ¨")
    workflow_list = st.session_state.get('workflow_result', None)
    workflow_item = workflow_list[0] if isinstance(workflow_list, list) and len(workflow_list) > 0 else workflow_list
    output_b64 = None
    if isinstance(workflow_item, dict):
        output_b64 = workflow_item.get("output_image") or workflow_item.get("image", {}).get("output_image")
    image_bytes = None
    if output_b64:
        try:
            image_bytes = base64.b64decode(output_b64)
        except Exception:
            image_bytes = None
    detailed_report = st.session_state.get('detailed_report', [])
    raw_detections = workflow_item.get("predictions", {}).get("predictions", []) if isinstance(workflow_item, dict) else []
    image_width = workflow_item.get("image", {}).get("width", 1280) if isinstance(workflow_item, dict) else 1280
    yolo_results = []
    for det in raw_detections:
        yolo_results.append({
            "class": det.get("class"),
            "confidence": det.get("confidence"),
            "box": {"x": det.get("x"), "y": det.get("y"), "width": det.get("width"), "height": det.get("height")}
        })
    main_screen_raw = st.session_state.get("main_screen")
    main_screen_id = None
    for i, det in enumerate(yolo_results):
        if main_screen_raw and det['box']['x'] == main_screen_raw.get('x') and det['box']['y'] == main_screen_raw.get('y') and det['class'] == main_screen_raw.get('class'):
            det['id'] = f"screen_{i}"
            main_screen_id = f"screen_{i}"
            break
    if not main_screen_id and len(yolo_results) > 0:
        for i, det in enumerate(yolo_results):
            if det.get("class") in ["screen", "monitor", "laptop"]:
                det['id'] = f"screen_{i}"
                main_screen_id = f"screen_{i}"
                break
    user_inputs = normalize_user_inputs()
    monitor_inch = st.session_state.get("monitor_inch", st.session_state.get("selected_screen_inch", None))
    analyzer = None
    try:
        ErgonomicsAnalyzer = globals().get("ErgonomicsAnalyzer")
        if ErgonomicsAnalyzer:
            analyzer = ErgonomicsAnalyzer(yolo_results, user_inputs or {}, image_width)
            if main_screen_id and monitor_inch:
                analyzer.set_main_screen_by_id(main_screen_id, str(monitor_inch))
    except Exception as e:
        logger.exception("Analyzer reconstruction failed: %s", e)
        analyzer = None
    if image_bytes and image_visualizer and analyzer and detailed_report:
        try:
            vis_img = image_visualizer.draw_feedback_on_image(image_bytes, detailed_report, analyzer)
            st.image(vis_img, caption="ğŸ” ì‹œê°í™”ëœ ê¶Œì¥ ë³€ê²½ ì‚¬í•­", use_column_width=True)
        except Exception as e:
            logger.exception("ì´ë¯¸ì§€ ì‹œê°í™” ì¤‘ ì˜¤ë¥˜: %s", e)
            st.warning("ì´ë¯¸ì§€ ì‹œê°í™”ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë‚´ë¶€ ì²˜ë¦¬ ì˜¤ë¥˜)")
    else:
        if not image_bytes:
            st.info("ì‹œê°í™”ì— ì‚¬ìš©í•  ì´ë¯¸ì§€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
        elif not image_visualizer:
            st.info("ì‹œê°í™” ëª¨ë“ˆ(image_visualizer)ì„ ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        elif not analyzer:
            st.info("ì‹œê°í™”ìš© ë¶„ì„ê¸°(Analyzer)ë¥¼ ì¬êµ¬ì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        elif not detailed_report:
            st.info("ì‹œê°í™”ì— í•„ìš”í•œ ìƒì„¸ ë¶„ì„ ë¦¬í¬íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
    st.subheader("ğŸ“‹ ìƒì„¸ ë¶„ì„ ë°ì´í„°")
    detailed_report = st.session_state.get('detailed_report', [])
    if not detailed_report:
        st.info("ìƒì„¸ ë¶„ì„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    else:
        for item in detailed_report:
            st.markdown(f"**í•­ëª©: {item.get('problem_id', 'UNKNOWN')}**")
            st.markdown(f"**ì§„ë‹¨: {item.get('severity', 'Low')}**")
            st.markdown(f"ì„¸ë¶€ ë‚´ìš©: {json.dumps(item.get('details', {}), ensure_ascii=False)}")
    if st.button("ë‹¤ì‹œ ë¶„ì„í•˜ê¸°", key="retry_p5", use_container_width=True):
        handle_retry()
